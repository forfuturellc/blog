<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>fftB | Pothole, an API rate-limit respecting approach</title>
  <meta name="description" content="  This post presents a rather simple approach to handle less frequent,short bursts of calls against a rate-limited API, for example,during application startu...">

  <link rel="stylesheet" href="/assets/bootstrap/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/main.css">

  
    
  <link rel="stylesheet" href="/css/post.css">
    
  <link rel="stylesheet" href="/css/syntax.css">
    
  

  

  <link rel="alternate" type="application/rss+xml" title="Forfuture: Blog" href="http://blog.forfuture.co.ke/feed.xml" />
</head>

  <body class="container-fluid">
    <header class="page-header">
    
<section id="site-build" role="build">
    <a id="build-link"
       href="https://github.com/forfuturellc/blog/commit/b46da955481debbfb0f0abfd7117107491e684f7">BUILD #18</a>
</section>


    <nav class="page-nav">
        <ul>
            <li><a href="/">top</a></li>
            <li><a href="/authors">authors</a></li>
            <li><a href="http://www.forfuture.co.ke" target="_blank">main website</a></li>
        </ul>
    </nav>
</header>

    <section class="page-content row">
        <div class="col-xs-12 col-md-6 col-md-offset-3">
        

<article class="post">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Pothole, an API rate-limit respecting approach</h1>
    <div class="post-meta">
        
        
        <span class="post-author">GochoMugo</span>
        
        <span class="post-author-email">
            <i class="fa fa-envelope"></i>
            <a class="x-msg"
               data-u="mugo"
               data-d="forfuture.co.ke"
               data-f="f" data-h="h"></a>
        </span>
        
        <span class="post-author-homepage"><i class="fa fa-globe"></i> <a href="http://www.gmugo.in">http://www.gmugo.in</a></span>
        <span class="post-author-github"><i class="fa fa-github"></i> <a href="https://github.com/GochoMugo">GochoMugo</a></span>
        
        <span class="post-date"><time datetime="2016-06-14T00:00:00+00:00" itemprop="datePublished">Jun 14, 2016</time></span>
    </div>

    <ul class="post-tags">
        
        <li><i class="fa fa-tag"></i> software architecture</li>
        
    </ul>

  </header>

  <div class="post-content" itemprop="articleBody">
    <blockquote>
  <p>This post presents a rather simple approach to handle <em>less frequent,
short bursts</em> of calls against a rate-limited API, for example,
during application startup. Some compromising is intended to avoid
having to require strict coordination of your application’s
components in using the API. It can be viewed as <strong>throttling</strong> with
the added feature of <strong>queuing functions</strong> for invocation at a later
time.</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>In some applications relying on a third-party API for data retrieval,
processing, etc., bursts of calls to the API may be experienced.
In particular, during the startup phase of the application, we may
require to fetch enormous amounts of data using multiple calls to the
same API. For example, …</p>

<p>The simplicity of this approach however comes at a price. It can
successfully applied in certain use cases with some trade-offs to consider.</p>

<h2 id="terminology">Terminology</h2>

<p>The rate-limiting parameters of the API are described here as follows:</p>

<p><em>Given a rate-limit of 50 requests per second,</em></p>

<ul>
  <li><strong>window</strong>: time intervals between resetting of number of allowable requests.</li>
  <li><strong>length of window</strong>: time, usually in milliseconds, a window lasts. In the
case above, the window’s length is <em>1 second (1000 ms)</em>.</li>
  <li><strong>size of window</strong>: number of requests allowed in a window. Here above,
the size is <em>50 requests</em>.</li>
  <li><strong>request</strong>: a call to an API. It does not necessarily require it be over
the network or be against a RESTful API. API of any kind should suffice.</li>
  <li><strong>pothole</strong>: a component that handles queueing and executing your functions
as specified in the windows’ parameters.</li>
</ul>

<h2 id="elaboration">Elaboration</h2>

<p>For this approach to work seamlessly in an application, the following
conditions would need to be satisfied:</p>

<ul>
  <li><strong>short window</strong>: The window needs to be short enough to allow us to
queue a request and wait for it to be completed in subsequent windows.</li>
  <li><strong>moderate number of requests in a burst</strong>: Preferably, have a request
be statisfied across 2-3 windows, in a worst-case scenario.</li>
</ul>

<p>Initially, we have an empty <strong>queue</strong> managed by a <strong>pothole</strong>. We
define the size and length of the window for our API. Instead of executing
our API calls directly, we queue them up in the pothole.</p>

<p>Let’s denote the number of remaining requests allowed as <strong>X</strong>. Executing
an API call (through the pothole) decrements <strong>X</strong> by one each time.
<strong>X</strong> is set to the size of the window at start.</p>

<ol>
  <li>While <strong>X</strong> is greater than 0 (zero) and the queue is empty, the pothole
executes the functions immediately without requiring to queue them</li>
  <li>(<strong>X</strong> is 0 (zero)) Queue up the functions</li>
  <li>Once the current window expires,
    <ul>
      <li><strong>X</strong> is reset to the size of the window</li>
      <li>Queued-up functions are executed, in the order they were queued.</li>
      <li>Should the length of the queue exceed the size of the window, at its
start, the functions remaining in the queue, once <strong>X</strong> hits 0 in this
window, will have to be executed in the next windows, in a similar
fashion.</li>
    </ul>
  </li>
</ol>

<h2 id="drawbacks">Drawbacks</h2>

<p>This approach can be difficult to use in such cases:</p>

<ul>
  <li><strong>high-level user request</strong>: this refers to request from users in front
of your application. Such applications need to be completed timely.
Passing them through a pothole may hurt user experience due to unexpected
lags.</li>
  <li><strong>polling</strong>: Functions doing polling should not be passed through
pothole as the intervals will not be respected. Also, consider a case where
two polling requests are queued up. Once conditions allow, the may both
be executed in quick succession, having them use the same set of
‘last-read’ parameters. This will make the second request mostly useless.</li>
  <li><strong>in-process functional</strong>: This is generally a problem with the
implementation of the Pothole strategy. In my implementation,
as used below in the demonstration, works with one process only.
It is possible to implement the strategy for use in distributed
fashions, such as in microservices.</li>
</ul>

<h2 id="demonstration">Demonstration</h2>

<p>I built a <a href="https://nodejs.org">Node.js</a> module, <a href="https://npmjs.com/package/pothole">pothole</a>, to apply this approach
in some of our applications.</p>

<p>In this simple demonstration, we shall have a server rate-limiting requests
at 10 requests per 30 seconds. Our client, on start, will do several number
of requests against the above server, with an aim of going over the limit.</p>

<p>You can obtain the working code below, in the post’s repo at
<a href="https://github.com/forfuturellc-x/blog-post-001">https://github.com/forfuturellc-x/blog-post-001</a>.</p>

<p>The server:</p>

<div class="highlight-file">

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'http'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">(</span><span class="nx">app</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">windowSize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>            <span class="c1">// The number of requests in a window.</span>
<span class="kd">var</span> <span class="nx">windowLength</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>   <span class="c1">// The time length of a window.</span>
<span class="kd">var</span> <span class="nx">remaining</span> <span class="o">=</span> <span class="nx">windowSize</span><span class="p">;</span>     <span class="c1">// A counter used to implement our rate-limiting</span>


<span class="c1">// This endpoint allows us to reset the counter just before</span>
<span class="c1">// running the client. Otherwise, we would hit the limit if we</span>
<span class="c1">// ran the client multiple, successive times. We hit this</span>
<span class="c1">// endpoint just before running the actual demo.</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/reset'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">remaining</span> <span class="o">=</span> <span class="nx">windowSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="na">message</span><span class="p">:</span> <span class="s2">"reset"</span> <span class="p">});</span>
<span class="p">});</span>


<span class="c1">// This endpoint basically decrements the counter on each request,</span>
<span class="c1">// if allowed, or returns an error to the client if the limit</span>
<span class="c1">// is exceeded.</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">503</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span>
            <span class="na">error</span><span class="p">:</span> <span class="p">{</span> <span class="na">message</span><span class="p">:</span> <span class="s2">"limit exceeded"</span> <span class="p">},</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="nx">remaining</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">remaining</span><span class="p">:</span> <span class="nx">remaining</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">});</span>
<span class="p">});</span>


<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">9080</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'server started'</span><span class="p">);</span>

    <span class="c1">// This interval resets the counter from one window to</span>
    <span class="c1">// the next.</span>
    <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">remaining</span> <span class="o">=</span> <span class="nx">windowSize</span><span class="p">;</span>
    <span class="p">},</span> <span class="nx">windowLength</span><span class="p">);</span>
<span class="p">});</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

</div>

<p>The server implements a very basic API rate-limiting scheme. It is very
naive and for demonstration purposes.</p>

<p>The client:</p>

<div class="highlight-file">

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'request'</span><span class="p">).</span><span class="nx">defaults</span><span class="p">({</span> <span class="na">json</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>

<span class="c1">// A multiplexer is exported by default. It basically manages your</span>
<span class="c1">// potholes for you i.e. you do not have to create and start them</span>
<span class="c1">// manually. A pothole is created on demand.</span>
<span class="kd">var</span> <span class="nx">pothole</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'pothole'</span><span class="p">);</span>

<span class="c1">// Our burst involves this number of requests. Consider this</span>
<span class="c1">// is an app start and we want to populate a database using</span>
<span class="c1">// a third-party API.</span>
<span class="kd">var</span> <span class="nx">burst</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">requestsDone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">lastRequestTime</span><span class="p">;</span>


<span class="c1">// We add a new `pothole` for the API labelled `my-api`, passing</span>
<span class="c1">// the definition of our window.</span>
<span class="nx">pothole</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">'my-api'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">window</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">size</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="na">length</span><span class="p">:</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">});</span>


<span class="c1">// We reset the limit/counter in the server. This is</span>
<span class="c1">// plainly for demonstration purposes. We do not really care</span>
<span class="c1">// if it succeeds or fails.</span>
<span class="nx">request</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"http://localhost:9080/reset"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{});</span>


<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">burst</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Enqueue a request. Consider if these requests were invoked</span>
    <span class="c1">// from different components of your application. Pothole</span>
    <span class="c1">// affords you a loose but effective coordination of</span>
    <span class="c1">// usage of the API.</span>
    <span class="nx">pothole</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="s2">"my-api"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"http://localhost:9080"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">requestsDone</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"ERROR occurred: %s"</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
                <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// Generating time diffs to demonstrate the momentary 'pause'</span>
            <span class="c1">// after every 10 requests, as Pothole waits for the next</span>
            <span class="c1">// window</span>
            <span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
            <span class="kd">var</span> <span class="nx">timeDiff</span> <span class="o">=</span> <span class="nx">lastRequestTime</span> <span class="p">?</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">lastRequestTime</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nx">lastRequestTime</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>

            <span class="c1">// For testing purposes, we disable logging the time diff</span>
            <span class="c1">// as it is not deterministic/constant. It will inevitably</span>
            <span class="c1">// vary.</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NO_TIME_DIFF</span><span class="p">)</span> <span class="nx">timeDiff</span> <span class="o">=</span> <span class="s1">'?'</span><span class="p">;</span>

            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'[%d] server response: remaining=%d +%sms'</span><span class="p">,</span> <span class="nx">requestsDone</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">remaining</span><span class="p">,</span> <span class="nx">timeDiff</span><span class="p">);</span>

            <span class="c1">// You need to stop your `pothole` so that the event loop</span>
            <span class="c1">// can exit cleanly. Why? A `pothole` uses a timer</span>
            <span class="c1">// internally.</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">requestsDone</span> <span class="o">===</span> <span class="nx">burst</span><span class="p">)</span> <span class="nx">pothole</span><span class="p">.</span><span class="nx">stop</span><span class="p">(</span><span class="s2">"my-api"</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

</div>

<p>You can notice we are simply passing functions to the Pothole
multiplexer above. This allows us to do almost anything within.
We could be doing network requests, as above, or disk IO, etc.</p>

<p>Sample output:</p>

<div class="highlight-file">

<figure class="highlight"><pre><code class="language-txt" data-lang="txt">[1] server response: remaining=9 +0ms
[2] server response: remaining=8 +2ms
[3] server response: remaining=7 +1ms
[4] server response: remaining=6 +0ms
[5] server response: remaining=5 +1ms
[6] server response: remaining=4 +0ms
[7] server response: remaining=3 +0ms
[8] server response: remaining=2 +1ms
[9] server response: remaining=1 +0ms
[10] server response: remaining=0 +0ms
[11] server response: remaining=9 +29965ms
[12] server response: remaining=8 +1ms
[13] server response: remaining=7 +1ms
[14] server response: remaining=6 +2ms
[15] server response: remaining=5 +0ms
[16] server response: remaining=4 +1ms
[17] server response: remaining=3 +1ms
[18] server response: remaining=2 +1ms
[19] server response: remaining=1 +1ms
[20] server response: remaining=0 +0ms
[21] server response: remaining=9 +30005ms
[22] server response: remaining=8 +2ms
[23] server response: remaining=7 +0ms
[24] server response: remaining=6 +1ms
[25] server response: remaining=5 +1ms
[26] server response: remaining=4 +2ms
[27] server response: remaining=3 +1ms</code></pre></figure>

</div>

<p>As you can notice after every 10 requests, there is an apparent
pause of ~30,000ms (30 seconds). This is attributed to Pothole
waiting for the next window before firing the queued requests.</p>

<p>Although the <code class="highlighter-rouge">for</code> loop executes in its entirety without ever pausing to
wait for a request to complete, the limit is never exceeded.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The benefit of loose but effective coordination of usage of the
API allows simpler architecture of application components. We
generally do <strong>not</strong> have to worry of rate-limiting issues in
suitable use cases. Pothole for the win!</p>

<hr />

<h4 id="references">References</h4>

<ol>
  <li><a href="https://nodejs.org">Node.js</a>: https://nodejs.org</li>
  <li><a href="https://npmjs.com/package/pothole">pothole, npm package</a>: https://npmjs.com/package/pothole</li>
  <li><a href="https://github.com/forfuturellc-x/blog-post-001">Github repository for this blog post</a>: https://github.com/forfuturellc-x/blog-post-001</li>
</ol>


  </div>

  <div class="post-footer">
      
      <div class="post-comments">
        <a href="/comments/001" target="_blank">
          goto comments; <i class="fa fa-arrow-circle-o-right"></i>
        </a>
      </div>
      
  </div>
</article>

        </div>
    </section>
    
<footer class="page-footer">
  <p>Copyright &copy; Forfuture, LLC
  &lt;<a class="x-msg"
         data-u="we"
         data-d="forfuture.co.ke"
         data-f="f" data-h="h"></a>&gt;</p>
  <p><a href="/tcs/">Terms and Conditions</a></p>
</footer>


    <script src="/assets/jquery/dist/jquery.min.js"></script>
<script src="/assets/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>





  </body>
</html>
